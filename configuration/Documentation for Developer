Documentation for Developers:

Summary of project:
    As mentioned in the porject specs, hikers, runners, and cyclists often record their activites using a phone, fitness watch, or dedicated GPS device. They may upload data from their devices to a system like Strava, MapMyRun, or RideWithGPS, which typically provide analysis, map display, and optional social media sharing.
    Existing services like Strava provide a variety of analyses and record keeping, but they typically do not provide a fully automated way to extract turn-by-turn directions from a recorded activity. For hikers and runners and some cyclists who travel off-road, this might be very difficult … there may be no suitable database from which to extract suitable cues. For road cyclists, however, it should be possible to extract turn-by-turn directions (a “cue sheet”) from a recording.
    That is what our system will do. The input will be a record consisting of a sequence of (latitude, longitude) pairs, possibly with other information. The output should be a list of turn-by-turn directions, e.g.,
        0.0 km Start at 19th and Agate
        1.2km Left on Franklin Blvd
        1.4km Left on 11th Ave
  
Background Information:
    Geocoding:
        Geocoding means translating place names or descriptions into geographic coordinates, usually latitude and longitude.
    Reverse Geocoding:
        Geocoding translates addresses into coordinates. Reverse geocoding, as you might guess, translates coordinates to addresses.
    Web Services:
        A web application (or “web app”) is designed for use by humans. A web service is designed for use by programs. Often it will be called a “web api” or just “api” (application program interface). Sometimes it will be called a REST API or REST service. REST stands for “representational state transfer”, and describes an architectural style for web services and web applications.

Description:
    Input -> GPX file
    Output -> a list of turn by turn directions
    Process:
        We divded the MVP in 3 "chunks", and assigend each module to one person (except for module 2, which was assigned to two people):
            1. Parse_gpx (pathname to gpx file) -> pandas dataframe
                * opens gpx file, pulls out lat, long, and time from each trkpt, and stores it in a data structure
                * gpxpy and pandas are the main libraries used in this module.
            2. Filtered_data (pandas dataframe) -> pandas dataframe with only data points immediately before and after each turn, and with street names added
                * The function takes in the dataFrame with pairs of long and lat. Then it operates the binary search to determine if the coordinate in a certain interval is on the same street.
                    ** Binary Seach: select the start, mid, and end data points in the dataFrame. We do the address lookup, and add their addresses to the corresponding long, lat lines. Then compare their addresses. If they are not in the same street, then split the dataFrame into half. Recursively take the halved as the input dataframe until it finds the data points on the same street in the input dataFrame section. 
                    ** address lookup: TAMU and Google has reverse geocoding service. They take the lat and long and output an address information in json format. Then we parse that json output to obtain the desired street name.
                    ** dataFrame clean-up/filter: there're non-turning points addresses have been added into dataFrame. Remain the turning points addresses unchanged, and remove non-turning points addresses. 
            3. Generate_directions (filtered pandas dataframe) -> csv file
                * Generates turn-by-turn directions as a text file
                    ** Calculates cumulative distance for each datapoint
			** Eliminates datapoints that are not immediately before or after a turn (if the name of the street changes, this is considered a turn)
                         ** The geopy library has a distance method that calculates the distance between two latitude/longitude coordinates
                    ** determines if it's a left or right turn (or straight ahead, but the street name changed
                          ** This was done by finding the closest point greater than 10m from a turning point (10m back from the pre-turn point, and 10m forward from a post-turn point), making a vector, and then using trigonometry to calculate the bearing from one vector to another. 
			** Puts turn and street information together into English sentences like "Turn left onto Main St."
                    ** returns this information in an updated DataFrame
         As for the remaining steps, we have the user interface.
         For the UI we decided to use Flask and Heroku:
                * We used the example code provided by Professor Michal Young to create our flask_main. We expect a gpx file from the user, which we will pass into our python program. 
                * At this point we also expect the user to enter his/her own API code, but in the future we hope to add an API to our configuration so that this step won't be asked of a user. For now we also include a link to the site where a user can obtain an API in about 2 minutes.
     
               
                
